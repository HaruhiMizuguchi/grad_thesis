# -*- coding: utf-8 -*-
"""metrics.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wIsrkVoMwfWomt9vNhzwWhXlBlkbxcV_

インスタンス数M、ラベル数Q

creds:M*Q 信頼度行列

test_target:M*Q 真のラベル
"""

import numpy as np

#creds = np.array([[0.2,0.3,0.2,0.9,0.1],[0.3,0.4,0.9,0.1,0.2]])
#test_target = np.array([[1,1,0,0,1],[1,1,1,1,1]])
#Outputs = np.array([[0.2,0.4,0.5,0.1,0.3]])
#test_target1 = np.array([[1,0,1,0,1]])

def one_error(creds,test_target):
  (ins_num,class_num) = np.shape(creds)
  oneerror = 0
  for i in range(0,ins_num):
    max_cred = 0
    for j in range(class_num):
      if creds[i,j] > max_cred:
        max_cred = creds[i,j]
        row = i
        col = j
    if test_target[row,col] == 0:
      oneerror += 1
  return(oneerror/ins_num)

def ranking_loss(creds,test_target):
  (ins_num,class_num) = np.shape(creds)
  ranking_loss = 0
  for i in range(0,ins_num):
    temp = 0
    yes_label = np.array([],dtype='int')
    not_label = np.array([],dtype='int')
    for j in range(0,class_num):
      if test_target[i,j] == 1:
        yes_label = np.append(yes_label,j)
      else:
        not_label = np.append(not_label,j)
    yes_label_num = len(yes_label)
    not_label_num = len(not_label)
    comb = yes_label_num * not_label_num
    for k in range(0,yes_label_num):
      for l in range(0,not_label_num):
        if creds[i,yes_label[k]] <= creds[i,not_label[l]]:
          temp +=1
    if comb != 0:
      ranking_loss += (temp / comb)
  return(ranking_loss / ins_num)

def coverage(creds,test_target):
  (ins_num,class_num) = np.shape(creds)
  cover = 0
  for i in range(0,ins_num):
    yes_label = np.array([])
    not_label = np.array([])
    for j in range(0,class_num):
      if test_target[i,j] == 1:
        yes_label = np.append(yes_label,j)
      #else:
      #  not_label = np.append(not_label,j)
    yes_label_num = len(yes_label)
    #sorted_creds = np.sort(creds[i])#昇順
    sorted_ind = np.argsort(creds[i])
    min_cover = class_num + 1
    for k in range(0,yes_label_num):
      for l in range(0,class_num):
        if sorted_ind[l] == yes_label[k]:
          if l < min_cover:
            min_cover = l + 1
    cover += (class_num - min_cover + 1)
  return((cover/class_num)/ins_num)